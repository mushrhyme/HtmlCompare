# HTML 문서 비교 도구 - 변경사항 탐지 로직

## 📋 개요

이 도구는 두 HTML 문서를 비교하여 변경사항을 탐지하고 하이라이팅하는 시스템입니다. 단어 단위 비교와 컨텍스트 기반 매칭을 통해 정확한 위치를 찾아냅니다.

## 🔍 전체 프로세스 흐름

```
1. HTML 파일 로드
   ↓
2. 텍스트 추출 및 정규화
   ↓
3. 단어 단위 변경사항 분석 (difflib)
   ↓
4. 컨텍스트 정보 추출 (앞뒤 3개 단어)
   ↓
5. HTML에서 변경사항 위치 찾기
   ↓
6. 컨텍스트 기반 매칭 및 점수 계산
   ↓
7. 최적 매칭 선택 및 하이라이팅
```

## 📝 단계별 상세 설명

### 1단계: HTML 파일 로드 및 텍스트 추출

**함수**: `load_file()`, `_extract_clean_text()`

- HTML 파일을 UTF-8로 읽어옴
- BeautifulSoup으로 파싱하여 텍스트만 추출
- 공백 정규화: 여러 공백을 하나로, `\u00a0`(non-breaking space)를 일반 공백으로 변환

```python
# 예시
"법인세   효과를  차감한" → "법인세 효과를 차감한"
```

### 2단계: 단어 단위 변경사항 분석

**함수**: `_analyze_char_word_changes()`

- 추출된 텍스트를 단어 단위로 분리 (`split()`)
- `difflib.SequenceMatcher`를 사용하여 두 문서 비교
- 변경 타입 감지:
  - `delete`: 삭제됨
  - `insert`: 추가됨
  - `replace`: 변경됨

**출력 예시**:
```python
{
    "type": "text",
    "status": "replace",
    "before": ["금액입니다."],
    "after": ["금액입니다.(*3)", "당분기", "중", ...],
    "before_position": (20037, 20043),
    "after_position": (19947, 20027),
    "before_context_before": ["법인세", "효과를", "차감한"],
    "before_context_after": ["(2)", "보고기간종료일", "현재"],
    ...
}
```

### 3단계: 컨텍스트 정보 추출

**함수**: `_extract_change_context()`

- 각 변경사항의 앞뒤 3개 단어씩 추출
- 원본(`before`)과 수정본(`after`) 각각에 대해 컨텍스트 저장
- 우선순위: `before_context` > `after_context` > 폴백(없음)

**컨텍스트 예시**:
- 앞 컨텍스트: "법인세 효과를 차감한"
- 뒤 컨텍스트: "(2) 보고기간종료일 현재"

### 4단계: HTML에서 변경사항 위치 찾기

**함수**: `_find_and_highlight_text_by_content()`

#### 4-1. 후보 탐색

1. **HTML의 모든 텍스트 노드 순회**
   - `soup.find_all(text=True)`로 모든 텍스트 노드 찾기
   - `<script>`, `<style>` 태그 내부는 제외
   - 이미 하이라이팅된 요소는 건너뛰기 (중복 방지)

2. **타겟 텍스트 포함 여부 확인**
   - `target_text in text_content`로 포함 여부 확인
   - 포함되면 후보로 추가

#### 4-2. 점수 계산

각 후보에 대해 두 가지 점수를 계산:

**A. 기본 유사도 (Basic Similarity)**
- `difflib.SequenceMatcher`를 사용한 텍스트 유사도
- 범위: 0.0 ~ 1.0
- 예: "금액입니다."와 "금액입니다. 추가 텍스트" → 약 0.8

**B. 컨텍스트 매칭 점수 (Context Score)**
- 컨텍스트가 제공된 경우에만 계산
- 함수: `_calculate_context_match_score_with_details()`

**컨텍스트 매칭 과정**:

1. **실제 컨텍스트 추출**
   - 타겟 텍스트 주변 100자씩 추출
   - 테이블 행(`<tr>`)인 경우: 같은 행의 모든 `<td>` 텍스트 수집
   - 일반 요소인 경우: 해당 요소의 텍스트 사용

2. **앞뒤 컨텍스트 비교**
   - 앞 컨텍스트: 실제 앞 컨텍스트의 끝부분 vs 찾는 앞 컨텍스트
   - 뒤 컨텍스트: 실제 뒤 컨텍스트의 앞부분 vs 찾는 뒤 컨텍스트
   - 각각 유사도 계산 후 가중 평균

3. **패턴 매칭**
   - "앞컨텍스트 + 타겟텍스트 + 뒤컨텍스트" 패턴 검색
   - 전체 패턴 유사도 계산

4. **최종 컨텍스트 점수**
   ```
   컨텍스트 점수 = (앞 컨텍스트 점수 × 0.4) + (뒤 컨텍스트 점수 × 0.4) + (패턴 점수 × 0.2)
   ```

#### 4-3. 최종 점수 계산

**컨텍스트가 있는 경우**:
```
최종 점수 = (기본 유사도 × 0.3) + (컨텍스트 점수 × 0.7)
```

**컨텍스트가 없는 경우**:
```
최종 점수 = 기본 유사도
```

### 5단계: 최적 매칭 선택

**정렬 기준**:
1. 컨텍스트 요구사항이 있는 매칭 우선
2. 최종 점수 높은 순

**검증**:
- 컨텍스트가 있는 경우: `context_score >= CONTEXT_MATCH_THRESHOLD (0.3)` 필수
- 최종 점수: `final_score >= ABSOLUTE_THRESHOLD (0.2)` 필수

**실패 시**: 시퀀스 매칭 시도 (부분 매칭 후보 탐색)

### 6단계: 하이라이팅 적용

**함수**: `_apply_highlighting()`

1. 하이라이팅된 `<span>` 태그 생성
2. CSS 클래스 적용:
   - `highlight-added`: 추가됨 (초록색)
   - `highlight-removed`: 삭제됨 (빨간색)
   - `highlight-modified`: 변경됨 (노란색)
3. 원본 텍스트 노드를 하이라이팅된 요소로 교체
4. 하이라이팅된 요소를 추적 set에 추가 (중복 방지)

## 🎯 핵심 알고리즘

### 컨텍스트 기반 매칭

**목적**: 동일한 텍스트가 여러 곳에 있을 때 정확한 위치를 찾기 위함

**예시 상황**:
- 문서에 "금액입니다"가 3곳에 존재
- 변경사항 #27: "금액입니다." → "금액입니다.(*3) ..."
- 컨텍스트: "법인세 효과를 차감한" ... "(2) 보고기간종료일 현재"

**동작**:
1. "금액입니다"를 포함하는 모든 노드 찾기 (3개)
2. 각 노드의 앞뒤 컨텍스트 추출
3. 컨텍스트 매칭 점수 계산
4. 컨텍스트 점수가 0.3 미만인 후보 제외
5. 가장 높은 점수의 후보 선택

### 중복 하이라이팅 방지

**문제**: 동일한 변경사항이 여러 곳에 적용될 때 중복 하이라이팅

**해결**:
- `highlighted_elements` set으로 이미 하이라이팅된 요소 추적
- 각 변경사항 처리 전에 이미 하이라이팅된 요소는 건너뛰기
- 하이라이팅된 `<span>` 내부의 텍스트도 건너뛰기

## ⚙️ 설정값

```python
ABSOLUTE_THRESHOLD = 0.2  # 최종 점수 최소 threshold
CONTEXT_MATCH_THRESHOLD = 0.3  # 컨텍스트 매칭 최소 threshold (컨텍스트가 있는 경우 필수)
```

## 🔧 주요 함수 목록

### 변경사항 분석
- `analyze_changes()`: 메인 분석 함수
- `_analyze_char_word_changes()`: 단어 단위 변경사항 분석
- `_extract_clean_text()`: HTML에서 텍스트 추출
- `_calculate_word_position()`: 단어 인덱스를 텍스트 위치로 변환

### 하이라이팅
- `create_html_with_highlighting()`: 하이라이팅된 HTML 생성
- `_apply_highlights_to_html()`: HTML에 하이라이팅 적용
- `_highlight_text_in_html()`: 텍스트 변경사항 하이라이팅
- `_find_and_highlight_text_by_content()`: 컨텍스트 기반 텍스트 찾기 및 하이라이팅

### 매칭 및 점수 계산
- `_calculate_context_match_score_with_details()`: 컨텍스트 매칭 점수 계산
- `_calculate_text_similarity()`: 텍스트 유사도 계산
- `_extract_change_context()`: 변경사항에서 컨텍스트 추출

## 🐛 디버깅

코드에 `print()` 문이 포함되어 있어 다음 정보를 확인할 수 있습니다:

- 매칭 발견 시: 찾는 텍스트, HTML 노드 텍스트, 기본 유사도
- 컨텍스트 매칭: 앞/뒤 컨텍스트 점수, 패턴 점수, 최종 컨텍스트 점수
- 최종 선택: 최종 점수, 컨텍스트 요구사항 여부
- 실패 시: 컨텍스트 매칭 실패, threshold 미달 등

## 📊 예시

### 입력
- 원본: "법인세 효과를 차감한 금액입니다. (2) 보고기간종료일 현재..."
- 수정본: "법인세 효과를 차감한 금액입니다.(*3) 당분기 중... (2) 보고기간종료일 현재..."

### 분석 결과
```python
{
    "status": "replace",
    "before": ["금액입니다."],
    "after": ["금액입니다.(*3)", "당분기", "중", ...],
    "before_context_before": ["법인세", "효과를", "차감한"],
    "before_context_after": ["(2)", "보고기간종료일", "현재"]
}
```

### 매칭 과정
1. "금액입니다"를 포함하는 모든 노드 찾기
2. 각 노드의 컨텍스트 확인
3. "법인세 효과를 차감한" + "금액입니다" + "(2) 보고기간종료일 현재" 패턴 매칭
4. 가장 높은 점수의 노드 선택
5. 하이라이팅 적용

## ⚠️ 주의사항

1. **컨텍스트가 없는 경우**: 기본 유사도만으로 매칭하므로 정확도가 낮을 수 있음
2. **동일 텍스트가 많을 경우**: 컨텍스트가 정확하지 않으면 잘못된 위치에 하이라이팅될 수 있음
3. **HTML 구조**: 테이블 구조(`<tr>`, `<td>`)를 우선 고려하지만, 일반 요소도 지원
4. **공백 정규화**: 모든 공백이 하나로 통일되므로 원본 HTML의 공백 구조는 보존되지 않음

